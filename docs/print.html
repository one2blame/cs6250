<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item "><a href="lesson1/lesson1.html"><strong aria-hidden="true">1.</strong> Lesson 1</a></li><li class="chapter-item "><a href="lesson2/lesson2.html"><strong aria-hidden="true">2.</strong> Lesson 2</a></li><li class="chapter-item "><a href="lesson3/lesson3.html"><strong aria-hidden="true">3.</strong> Lesson 3</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome" id="welcome">Welcome</a></h1>
<p>This notebook contains my personal notes for CS6250: Computer Networks, offered
at the Georgia Institute of Technology. A summary of the course follows:</p>
<p>This project-based course will explore research topics in computer networking,
primarily at the IP layer and above. Students will gain exposure to burgeoning
areas of computer networking and learn how to use the tools commonly used for
networking research, today.</p>
<h2><a class="header" href="#course-links" id="course-links">Course links</a></h2>
<ul>
<li><a href="https://omscs.gatech.edu/cs-6250-computer-networks">https://omscs.gatech.edu/cs-6250-computer-networks</a></li>
</ul>
<h1><a class="header" href="#lesson-1" id="lesson-1">Lesson 1</a></h1>
<p>This lesson covers internet history, original design choices and principles of
the Internet's architecture. This lesson also covers how these design choices
have shaped the Internet's architecture over time, which resembles an hourglass
figure. Finally, this lesson explores what the Internet could be if we started
over from a clean slate with what we know now. This discussion will cover
example architectural design approaches that optimize for network control,
management and accountability - goals that were not considered when the Internet
was first created.</p>
<h2><a class="header" href="#internet-architecture-introduction" id="internet-architecture-introduction">Internet Architecture Introduction</a></h2>
<p>This section covers how two hosts running the same application can communicate
despite being located in different types of networks. An example is given where
two BitTorrent clients communicate, one using Ethernet and the other using
WiFi. Because they are using an Application Programming Interface to agree
upon one standard for communication, they both utilize multiple layers of APIs
to transfer data.</p>
<p>An analogy is provided using the airline system, where there are a number of
steps, layers, and functionalities that define how a person can travel from
one location to another using multiple airlines and airplanes.</p>
<p>What are the advantages of having a layered networking stack?</p>
<ul>
<li><strong>Scalability, modularity, and flexibility</strong></li>
</ul>
<h2><a class="header" href="#the-osi-model" id="the-osi-model">The OSI Model</a></h2>
<p>This section discusses the
International Organization for Standardization's (ISO)
Open Systems Interconnection (OSI) model, consisting of the following layers:</p>
<ul>
<li>Application Layer</li>
<li>Presentation Layer</li>
<li>Session Layer</li>
<li>Transport Layer</li>
<li>Network Layer</li>
<li>Data Link Layer</li>
<li>Physical Layer</li>
</ul>
<p>While the OSI model has its advantages, what are its disadvantages?</p>
<ol>
<li>Some layers functionality relies upon information from other layers,
violating the goal of layer separation.</li>
<li>One layer may duplicate the work of lower layer functionalities - error
recovery can occur in lower layers, but also in higher layers.</li>
<li>Additional overhead is incurred by the abstraction of information between
layers.</li>
</ol>
<h2><a class="header" href="#application-presentation-and-session-layers" id="application-presentation-and-session-layers">Application, Presentation, and Session Layers</a></h2>
<p>Note: in the TCP/IP model of the Internet protocol stack, these three layers are
combined. This is due to the fact that these three layers are so similar and
usually implemented by application developers.</p>
<h3><a class="header" href="#the-application-layer" id="the-application-layer">The Application Layer</a></h3>
<p>Includes some popular protocols:</p>
<ul>
<li>HTTP (web content delivery)</li>
<li>SMTP (e-mail)</li>
<li>FTP  (file transfer)</li>
<li>DNS  (domain name resolution)</li>
</ul>
<p>Packets of information at this layer are referred to as <strong>messages</strong>.</p>
<h3><a class="header" href="#the-presentation-layer" id="the-presentation-layer">The Presentation Layer</a></h3>
<p>Plays an intermediate role in formatting the information received from the
Session Layer, and delivers the formatted data to the Application Layer. This
could include something like formatting a video stream or converting bytes from
Big to Little Endian.</p>
<h3><a class="header" href="#the-session-layer" id="the-session-layer">The Session Layer</a></h3>
<p>This layer is responsible for managing the different Transport Layer streams
that belong to the same session between Application processes over a network.
For example, in teleconferencing applications, it ties together the audio and
video streams of a session.</p>
<h3><a class="header" href="#the-transport-layer" id="the-transport-layer">The Transport Layer</a></h3>
<p>This layer is responsible for the end-to-end communication between two
endpoints. There exist two protocols for the Transport Layer: TCP and UDP.
TCP is a connection-oriented service that guarantees delivery of Application
Layer messages, flow control, and congestion control. UDP is a connection-less
service that doesn't provide any of the previously mentioned features for
Application Layer messages. At this layer, packets of information are referred
to as <strong>segments</strong>.</p>
<h3><a class="header" href="#the-network-layer" id="the-network-layer">The Network Layer</a></h3>
<p>The Network Layer is responsible for routing <strong>datagrams</strong> from one Internet
host to another. At this layer, packets of information are referred to as
<strong>datagrams</strong>. At this layer, the IP protocol is defined, which defines:</p>
<ul>
<li>Fields of an IP datagram</li>
<li>How the source/destination hosts and intermediate routers use fields of a
datagram to ensure the datagram is delivered to the correct host</li>
<li>Routing protocols to determine the routes that datagrams can take between the
source and destination hosts</li>
</ul>
<h3><a class="header" href="#data-link-layer" id="data-link-layer">Data Link Layer</a></h3>
<p>At this layer, packets of information are referred to as <strong>frames</strong>. Example
protocols defined in this layer are: Ethernet, PPP, and WiFi. This layer is
responsible for moving frames from one node to the next within a network, not
across. The Data Link Layer offers reliable transmission of <strong>frames</strong> between
two links, however, the reliable delivery service is different than what is
offered at the Transport Layer.</p>
<h3><a class="header" href="#the-physical-layer" id="the-physical-layer">The Physical Layer</a></h3>
<p>This layer facilities the interaction with the actual hardware that will be
transmitting a frame between two nodes connected through a physical link. The
protocols in this layer depend on the link and transmission medium of the link.
Different Physical Layer protocols are used for Ethernet depending upon if the
transmission medium is twister-pair copper wire, coaxial cable, or fiber optic
cable.</p>
<h2><a class="header" href="#encapsulation" id="encapsulation">Encapsulation</a></h2>
<p>Encapsulation is the concept that, as packets of information travel up and down
the network stack, they are correctly encapsulated for that network layer in
order for the packet to be inspected, routed, transmitted, etc. correctly. As
packets of information transfer between each layer of the network stack, they
are encapsulated or de-encapsulated accordingly.</p>
<h3><a class="header" href="#intermediate-devices" id="intermediate-devices">Intermediate devices</a></h3>
<p>Inspecting the OSI and TCP/IP model and the makeup of intermediate devices,
we can recognize that intermediate devices, routers and switches, usually only
implement layers 1 - 3. This is a design choice, the backbone of the internet
can be less complex and only focus on layers 1 - 3 for routing and transmitting
data. All of the other computationally intensive operations are left up to the
endpoints / hosts at the edge of the network.</p>
<h2><a class="header" href="#the-end-to-end-principle" id="the-end-to-end-principle">The End to End Principle</a></h2>
<p>The end-to-end (e2e) principle is a design choice that characterized and shaped
significantly the current architecture of the Internet. The e2e principle
suggests that specific application-level functions usually cannot, and
preferably should not be built into the lower levels of the system at the core
of the network.</p>
<p>What were the designers’ original goals that led to the e2e principle?</p>
<p><strong>Moving functions and services closer to the applications that use them,
increases the flexibility and the autonomy of the application designer to offer
these services to the needs of the specific application.
Thus, the higher-level protocol layers, are more specific to an application.</strong> </p>
<h3><a class="header" href="#violations-of-the-end-to-end-principle" id="violations-of-the-end-to-end-principle">Violations of the End to End Principle</a></h3>
<p>Some of examples of the E2E principle being violated are firewalls and Network
Address Translation (NAT). Firewalls filter traffic based upon some Access
Control List (ACL), monitoring network traffic and allowing or dropping traffic
based upon it's malicious-ness. Firewalls violate the E2E principle because
they are intermediate devices that are operations between two endpoints
and can drop the communication between said endpoints.</p>
<p>Network Address Translation (NAT) violates the E2E principle, but was designed
as an after-thought because the Internet was due to run out of public IP address
space if too many endpoints were added to the network. NAT violates the E2E
principle because we are using an intermediate device to conduct translation
between two endpoints that would otherwise be unable to communicate - the host
on the private network has a private IP address that is not globally route-able.</p>
<h2><a class="header" href="#evolutionary-architecture-model-evoarch" id="evolutionary-architecture-model-evoarch">Evolutionary Architecture Model (EvoArch)</a></h2>
<p>Researchers have suggested a model - the Evolutionary Architecture model or
EvoArch - that can help to study layered architectures, and their evolution in a
quantitative manner.</p>
<h3><a class="header" href="#implications-for-the-internet-architecture-and-its-future" id="implications-for-the-internet-architecture-and-its-future">Implications for the Internet Architecture and its Future</a></h3>
<p>The EvoArch model suggests that the TCP/IP stack was not trying to compete with
the telephone network services. The TCP/IP was mostly used for applications such
as FTP, E-mail, and Telnet, so it managed to grow and increase its value without
competing or being threatened by the telephone network, at that time that it
first appeared. Later it gained even more traction, with numerous and powerful
applications relying on it. The waist of the Internet architecture is narrow,
but also the next higher layer (the transport layer) is also very narrow and
stable. So, the transport layer acts as an “evolutionary shield” for IPv4,
because any new protocols that might appear at the transport layer are unlikely
to survive the competition with TCP and UDP which already have multiple
products. In other words, the stability of the two transport protocols adds to
the stability of IPv4, by eliminating any potential new transport protocols,
that could select a new network layer protocol instead of IPv4.</p>
<h2><a class="header" href="#interconnecting-hosts-and-networks" id="interconnecting-hosts-and-networks">Interconnecting Hosts and Networks</a></h2>
<p>Below are descriptions of the devices that offer different services and operate
over different layers:</p>
<ul>
<li><strong>Repeaters and Hubs</strong> - Operate on the physical layer, receive and forward
signals to connect different Ethernet segments, providing connectivity between
hosts that are directly connected. Hosts connected to these devices reside
within the same collision domain, causing them to compete for the same link.</li>
<li><strong>Bridges and Layer 2 switches</strong> - Operate on the data link layer based on
MAC addresses. They receive packets and forward them to the appropriate
destination. Limitations include their finite bandwidth, causing them to drop
packets if the buffer space of the bridge or the switch is too full.</li>
<li><strong>Routers and Layer 3 switches</strong> - Operate on the network layer, routing
packets between different networks.</li>
</ul>
<h3><a class="header" href="#learning-bridges" id="learning-bridges">Learning Bridges</a></h3>
<p>A <strong>learning bridge</strong> is a bridge that learns, populates, and maintains a
forwarding table. The bridge consults the table so that it only forwards frames
on specific ports, rather than over all ports. When the learning bridge receives
any frame, it uses this as a &quot;learning opportunity&quot; to learn which hosts are
reachable through which ports. This is because the bridge knows what port a
specific host is communicating over, allowing it to correlate host with port.</p>
<h2><a class="header" href="#looping-problem-in-bridges-and-the-spanning-tree-algorithm" id="looping-problem-in-bridges-and-the-spanning-tree-algorithm">Looping Problem in Bridges and the Spanning Tree Algorithm</a></h2>
<p>In the lectures, a problem is presented in which bridges can infinitely forward
packets if the network is configured in a circular manner. The Spanning Tree
Algorithm works to solve this by having each bridge advertise its NodeID, the
NodeID of the node that it accepts as the root node, and its distance from the
root node. Implementing the Spanning Tree Algorithm, the bridges will coordinate
to eliminate loops in the network, and offending bridges will no longer forward
traffic if they deem they are the cause of the loop.</p>
<h1><a class="header" href="#lesson-2" id="lesson-2">Lesson 2</a></h1>
<p>This lecture covers the transport layer and mainly focuses on the TCP protocol.</p>
<h2><a class="header" href="#introduction-to-the-transport-layer" id="introduction-to-the-transport-layer">Introduction to the Transport Layer</a></h2>
<p>This layer provides and end-to-end connection between two applications that
are running on different hosts. The transport layer provides this logical
connection regardless if the hosts are in the same network.</p>
<ul>
<li>Messages at the transport layer are called <strong>segments</strong>.</li>
<li>The transport layer provides functionalities like data transfer integrity,
flow control, transmission control, etc. - things the Network Layer is unable
to provide.</li>
</ul>
<p>There are two main protocols:</p>
<ul>
<li><strong>Transmission Control Protocol (TCP)</strong> - connection-oriented protocol.
Provides reliable transmission, transmission control, flow control, and
congestion control.</li>
<li><strong>User Datagram Protocol (UDP)</strong> - connection-less protocol. Provides no
congestion control, connection management, or similar overhead / mechanisms.
Useful for real-time applications that are sensitive to delays. Packet structure
is as follows:
<ul>
<li>Source and destination ports.</li>
<li>Length of the segment.</li>
<li>Checksum.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#multiplexing-and-demultiplexing" id="multiplexing-and-demultiplexing">Multiplexing and Demultiplexing</a></h3>
<p>Enabled by the use of <strong>ports</strong> at the Transport Layer - used to multiplex
multiple connections for a host. A combination of IP address and Port Number
consititutes a <strong>socket</strong>.</p>
<ul>
<li><strong>Multiplexing</strong> - the encapsulation of data into segments with header
information identifying the sender and receiver of a segment.</li>
<li><strong>Demultiplexing</strong> - the unpacking of a segment and interpretation of a header
in order to deliver the data to its respective application.</li>
</ul>
<h2><a class="header" href="#goals-for-congestion-control" id="goals-for-congestion-control">Goals for congestion control</a></h2>
<ul>
<li><strong>Efficiency</strong> - throughput and utilization of the network should be as high
as possible.</li>
<li><strong>Fairness</strong> - each device should get a fair share of the network bandwitdth.</li>
<li><strong>Low delay</strong> - ensuring applications sensitive to delays receive necessary
data as quickly as possible.</li>
<li><strong>Fast convergence</strong> - flow should be able to converge to fair allocation
quickly.</li>
</ul>
<h2><a class="header" href="#end-to-end-vs-network-assisted-congestion-control" id="end-to-end-vs-network-assisted-congestion-control">End-to-end vs network-assisted congestion control</a></h2>
<p><strong>End-to-end</strong> congestion control involves the hosts communicating and using the
same protocols in order to control the congestion on the network. This is
currently implemented with TCP.</p>
<p><strong>Network-assisted</strong> congestion control involves network devices such as core
routers implementing congestion control, which does not follow the end-to-end
design of the Internet that is currently adopted. This design would require
core routers to have much more computing power.</p>
<h3><a class="header" href="#how-do-hosts-detect-congestion" id="how-do-hosts-detect-congestion">How do hosts detect congestion?</a></h3>
<p>Hosts detecting congestion through packet delay and packet loss. The indicators
can both be detected by TCP via a check of round-trip time and a loss of
segments for each transmission window.</p>
<h2><a class="header" href="#definitions" id="definitions">Definitions</a></h2>
<ul>
<li><strong>flow control</strong> - controlling the transmission rate to proctect the
receiver's buffer.</li>
<li><strong>congestion control</strong> - controlling the transmission rate to protect the
network from congestion.</li>
</ul>
<h1><a class="header" href="#intradomain-routing" id="intradomain-routing">Intradomain routing</a></h1>
<p>This lesson focuses on routing at the Network Layer within a single domain. It
covers:</p>
<ul>
<li>Protocols that determine paths between sources and destinations within a
single domain.</li>
<li>Link-state and distance-vector algorithms.</li>
<li>RIP</li>
<li>OSPF</li>
<li>Convergence</li>
<li>Using routing protocols to steer traffic, avoiding congested links.</li>
</ul>
<h2><a class="header" href="#link-state-routing-algorithm" id="link-state-routing-algorithm">Link-state routing algorithm</a></h2>
<p>The <strong>link-state</strong> routing algorithm essentially mimics Dijkstra's algorithm,
representing the network as a graph. <code>u</code> is the source node and <code>v</code> is every
other node in the network. The cost is represented by <code>D(v)</code>, which is the
current least cost path from <code>u</code> to node <code>v</code>.</p>
<p>The <code>initialization</code> step of the algorithm determines all the currently known
least-cost paths from <code>u</code> to its adjacent neighbors. Unknown costs for nodes
not directly attached to <code>u</code> have a cost of infinity.</p>
<p>The <code>iterative</code> step of the algorithm follows a loop that is executed for
every destination node <code>v</code> in the network, continuously discovering nodes,
costs, and the overall cost for a path of <code>u</code> to <code>v</code>.</p>
<p>The algorithm exits by returning the shortest paths and their costs from the
source node to every other node in the network.</p>
<p>The computational complexity of the <strong>link-state</strong> routing algorithm is
<strong>O(n^2)</strong>.</p>
<h2><a class="header" href="#distance-vector-routing-algorithm" id="distance-vector-routing-algorithm">Distance-vector routing algorithm</a></h2>
<p>The <strong>distance-vector</strong> routing algorithm is:</p>
<ul>
<li>iterative</li>
<li>asynchronous</li>
<li>distributed</li>
<li>based on the Bellman Ford Algorithm</li>
</ul>
<p>Each node maintains its own distance vector with the costs to reach every other
node in the network. Occasionally, the routers will advertise its distance
vector information to adjacent nodes. The adjacent nodes receive that
information, update their own distance vectors, and exchange with other adjacent
nodes.</p>
<h2><a class="header" href="#routing-information-protocol-rip" id="routing-information-protocol-rip">Routing Information Protocol (RIP)</a></h2>
<p>Based on the <strong>distance-vector</strong> routing algorithm, each node maintains a RIP
table (Routing Table) which has one row for each subnet in the autonomous
system. RIP version 2 allows subnet entries to be aggregated using route
aggregation techniques.</p>
<p>In RIP, if a router does not hear from its neighbor at least every 180 seconds,
that neighbor is considered to be no longer reachable. The RIP table is modified
and changes are propagated throughout the network. Requests and responses are
sent over UDP, port <code>520</code>, layered on top of IP. RIP is actually implemented at
the Application Layer. RIP challenges include:</p>
<ul>
<li>Updating routes</li>
<li>Reducing convergence time</li>
<li>Avoiding loops / counting to infinity</li>
</ul>
<h2><a class="header" href="#open-shortest-path-first-ospf" id="open-shortest-path-first-ospf">Open Shortest Path First (OSPF)</a></h2>
<p>Based on the <strong>link-state</strong> routing algorithm, finds the best path between a
source and destination router. Introduced as an advancement to RIP, uses
flooding of link-state information and a Dijkstra least-cost pathing algorithm.
Advances over RIP include:</p>
<ul>
<li>Authentication of messages exchanged between routers</li>
<li>Options to use multiple same cost paths</li>
<li>Support for router hierarchy within a domain</li>
</ul>
<h3><a class="header" href="#hierarchy" id="hierarchy">Hierarchy</a></h3>
<p>OSPF autonomous systems can be configured into areas with their own link-state
routing algorithms - border routers are responsible for routing packets outside
of the area (the backbone area).</p>
<h3><a class="header" href="#operation" id="operation">Operation</a></h3>
<p>A graph of the autonomous system is constructed, then each node considers itself
the root and computes the shortest path to all subnets, running Dijkstra's
algorithm locally. Link costs are preconfigured by a network administrator.
Whenever a link's state changes, the router broadcasts routing information to
all other routers in the autonomous system.</p>
<h2><a class="header" href="#definitions-1" id="definitions-1">Definitions</a></h2>
<ul>
<li><strong>Forwarding</strong> - a the Network Layer, transferring a packet from an incoming
link to an outgoing link within a single router.</li>
<li><strong>Routing</strong> - how routers work together using routing protocols to determine
the good paths over which the packets travel from the source to the destination
node.</li>
<li><strong>intradomain routing algorithms</strong> - routing within the same adminisrative
domain. Also known as <strong>Interior Gateway Protocols (IGPs)</strong>.</li>
<li><strong>forwarding information base</strong> - database used when a data packat arrives at
an interface card of the router, helps the router determine the next hop for the
packet.</li>
<li><strong>hot potato routing</strong> - a technique / practice of choosing a path within the
network by choosing the closes egress point based on intradomain path cost.</li>
</ul>
<h2><a class="header" href="#quizzes" id="quizzes">Quizzes</a></h2>
<p><img src="lesson3/./assets/quiz1.png" alt="quiz1" />
<img src="lesson3/./assets/quiz2.png" alt="quiz2" /></p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ol>
<li><a href="lesson3/./pdfs/82.pdf">Experience in Black-box OSPF Measurement</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
